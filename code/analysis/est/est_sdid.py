# -*- coding: utf-8 -*-
"""est_sdid.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TBa3-onaPERLHCdUb7Tob_lC2pxb0br2

**Synthetic DID**

参考

https://dropout009.hatenablog.com/entry/2019/05/06/185620
https://github.com/synth-inference/synthdid
https://github.com/dropout009/sdid_python/blob/master/src/sdid.ipynb

# New Section
"""

### importing library

import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
import seaborn as sns

from IPython.display import set_matplotlib_formats
set_matplotlib_formats('retina')

import cvxopt
from cvxopt import matrix

from sklearn.metrics import mean_squared_error

import warnings
warnings.simplefilter('ignore')

### constructing function

def root_mean_squared_error(y_true, y_pred):
    return np.sqrt(mean_squared_error(y_true, y_pred))

def est_omega(Y_c_pre, Y_t_pre, zeta=1):
    Y_c_pre = Y_c_pre.T
    nrow = Y_c_pre.shape[0]
    ncol = Y_c_pre.shape[1]
    
    assert nrow == Y_t_pre.shape[0], print(f'shape error! {nrow} != {Y_t_pre.shape[0]}')
    
    P = np.diag(np.concatenate([np.repeat(zeta, ncol), np.repeat(1/nrow, nrow)]))
    q = np.zeros(ncol+nrow)
    A = np.concatenate([np.concatenate([Y_c_pre, np.diag(np.ones(nrow))], axis=1),
                        np.concatenate([np.ones(ncol), np.zeros(nrow)]).reshape(1, -1)])
    b = np.concatenate([Y_t_pre, np.ones(1)])

    G = - np.concatenate([np.diag(np.ones(ncol)), np.zeros([ncol, nrow])], axis=1)
    h = np.zeros(ncol)

    P, q, A, b, G, h = matrix(P), matrix(q), matrix(A), matrix(b), matrix(G), matrix(h)

    sol = cvxopt.solvers.qp(P=P,q=q, A=A, b=b, G=G, h=h)
    
    return(np.array(sol['x'][:ncol]))

def est_lambda(Y_c_pre, Y_c_post, zeta=1):
    nrow = Y_c_pre.shape[0]
    ncol = Y_c_pre.shape[1]
    
    assert nrow == Y_c_post.shape[0], print(f'shape error! {nrow} != {Y_c_post.shape[0]}')
    
    P = np.diag(np.concatenate([np.repeat(zeta, ncol), np.repeat(1/nrow, nrow), np.array([1e-6])]))
    q = np.zeros(ncol+nrow + 1)
    A = np.concatenate([np.concatenate([Y_c_pre, np.diag(np.ones(nrow)), -np.ones([nrow, 1])], axis=1),
                        np.concatenate([np.ones(ncol), np.zeros(nrow), np.zeros(1)]).reshape(1, -1)])
    b = np.concatenate([Y_c_post, np.ones(1)])

    G = - np.concatenate([np.diag(np.ones(ncol)), np.zeros([ncol, nrow]), np.zeros([ncol, 1])], axis=1)
    h = np.zeros(ncol)

    P, q, A, b, G, h = matrix(P), matrix(q), matrix(A), matrix(b), matrix(G), matrix(h)

    sol = cvxopt.solvers.qp(P=P,q=q, A=A, b=b, G=G, h=h)
    
    return(np.array(sol['x'][:ncol]))

### setup
"""
df_origin = pd.read_csv("df_use_sdid_com_iner_elite_gov_povln.csv")
col_t = df_origin.query("com_capital_2015 == 1")["comid"]
df_origin = df_origin.filter(["comid", "com_iner_elite_gov_povln_2015", "com_iner_elite_gov_povln_2018", "com_iner_elite_gov_povln_2020"])
df_origin = df_origin.melt(id_vars= ["comid"], value_vars = ["com_iner_elite_gov_povln_2015", "com_iner_elite_gov_povln_2018", "com_iner_elite_gov_povln_2020"])
df_origin = df_origin.pivot(index = "variable", columns="comid", values = "value")
State_Name = df_origin.columns
df_origin.columns = [''] * len(df_origin.columns)

"""
df_origin = pd.read_csv("df_imp_use_sdid_iner_elite_gov_povln.csv")
col_t = df_origin.query("capital_2015 == 1")["hhid"]
df_origin = df_origin.filter(["hhid", "iner_elite_gov_povln_2015", "iner_elite_gov_povln_2018", "iner_elite_gov_povln_2020"])
df_origin = df_origin.melt(id_vars= ["hhid"], value_vars = ["iner_elite_gov_povln_2015", "iner_elite_gov_povln_2018", "iner_elite_gov_povln_2020"])
df_origin = df_origin.pivot(index = "variable", columns="hhid", values = "value")
State_Name = df_origin.columns
df_origin.columns = [''] * len(df_origin.columns)

col_t

Y = df_origin.T.values
post_periods = 1
focal_time = range(1, Y.shape[1]) #time.range
#sigma_sq = np.var(Y[:, 1:] - Y[:, :3]) # time
Y[col_t.index, :]

dfs = []
for s, sname in enumerate(col_t):
    for t in focal_time:
        
        Y_c = np.delete(Y, s, axis=0)
        Y_t = Y[s, :] # sはenumerate関数で取得されたindex

        Y_c_pre = Y_c[:, :t]
        Y_c_post = Y_c[:, t]
        Y_t_pre = Y_t[:t]
        Y_t_post = Y_t[t]

        omega_hat = est_omega(Y_c_pre, Y_t_pre, zeta=1)
        lambda_hat = est_lambda(Y_c_pre, Y_c_post, zeta = 1)

        sum_omega_YiT = omega_hat.T @ Y_c_post
        sum_lambda_YNt= lambda_hat.T @ Y_t_pre
        sum_omega_lambda_Yit = omega_hat.T @ Y_c_pre @ lambda_hat

        Yhat_sdid = sum_omega_YiT + sum_lambda_YNt - sum_omega_lambda_Yit
        Yhat_sc = sum_omega_YiT
        Yhat_did = Y_c_post.mean() + Y_t_pre.mean() - Y_c_pre.mean()

        dfs.append(pd.DataFrame(data={'State_ID': s, 'State_Name': sname, 'Year': 2015+t, 'DID': Yhat_did, 'SC': Yhat_sc[0], 'SDID': Yhat_sdid[0], 'Y': Y_t_post}))

df_result = pd.concat(dfs, axis=0, ignore_index=True)

#
df_result

### result
rmse_did, rmse_sc, rmse_sdid = [], [], []
for s, sname in enumerate(col_t):
    df_tmp = df_result[df_result.State_Name == sname]
    rmse_did.append(root_mean_squared_error(df_tmp.Y, df_tmp.DID))
    #rmse_sc.append(root_mean_squared_error(df_tmp.Y, df_tmp.SC))
    rmse_sdid.append(root_mean_squared_error(df_tmp.Y, df_tmp.SDID))

df_rmse = pd.DataFrame(data={ 'DID': rmse_did, 'SDID': rmse_sdid}) #'SC': rmse_sc, 
df_rmse

df_result.Y
df_result.SDID
np.sum(df_result.query("Year == 2017").Y - df_result.query("Year == 2017").SDID) / len(df_result.query("Year == 2017"))

df_rmse.describe()

### SDID vs DID
fig, ax = plt.subplots(figsize=(5, 5))
ax.set_xscale("log", basex=2)
ax.set_yscale("log", basey=2)
#ax.plot(range(1,40), range(1,40), color = 'gray')
ax.plot([0, 2], [0, 2], ls="--", c=".2")
sns.scatterplot(df_rmse.SDID, df_rmse.DID, ax=ax)
plt.tight_layout()
#fig.savefig('../figure/did_sdid.png', dpi=272)

